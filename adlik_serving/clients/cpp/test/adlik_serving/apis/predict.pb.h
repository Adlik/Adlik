// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: adlik_serving/apis/predict.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_adlik_5fserving_2fapis_2fpredict_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_adlik_5fserving_2fapis_2fpredict_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/tensor.pb.h"
#include "adlik_serving/framework/domain/model_spec.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_adlik_5fserving_2fapis_2fpredict_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_adlik_5fserving_2fapis_2fpredict_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto;
namespace adlik {
namespace serving {
class PredictRequest;
class PredictRequestDefaultTypeInternal;
extern PredictRequestDefaultTypeInternal _PredictRequest_default_instance_;
class PredictRequest_Class;
class PredictRequest_ClassDefaultTypeInternal;
extern PredictRequest_ClassDefaultTypeInternal _PredictRequest_Class_default_instance_;
class PredictRequest_InputsEntry_DoNotUse;
class PredictRequest_InputsEntry_DoNotUseDefaultTypeInternal;
extern PredictRequest_InputsEntry_DoNotUseDefaultTypeInternal _PredictRequest_InputsEntry_DoNotUse_default_instance_;
class PredictRequest_Output;
class PredictRequest_OutputDefaultTypeInternal;
extern PredictRequest_OutputDefaultTypeInternal _PredictRequest_Output_default_instance_;
class PredictRequest_OutputFilterEntry_DoNotUse;
class PredictRequest_OutputFilterEntry_DoNotUseDefaultTypeInternal;
extern PredictRequest_OutputFilterEntry_DoNotUseDefaultTypeInternal _PredictRequest_OutputFilterEntry_DoNotUse_default_instance_;
class PredictResponse;
class PredictResponseDefaultTypeInternal;
extern PredictResponseDefaultTypeInternal _PredictResponse_default_instance_;
class PredictResponse_Class;
class PredictResponse_ClassDefaultTypeInternal;
extern PredictResponse_ClassDefaultTypeInternal _PredictResponse_Class_default_instance_;
class PredictResponse_Classes;
class PredictResponse_ClassesDefaultTypeInternal;
extern PredictResponse_ClassesDefaultTypeInternal _PredictResponse_Classes_default_instance_;
class PredictResponse_Output;
class PredictResponse_OutputDefaultTypeInternal;
extern PredictResponse_OutputDefaultTypeInternal _PredictResponse_Output_default_instance_;
class PredictResponse_OutputsEntry_DoNotUse;
class PredictResponse_OutputsEntry_DoNotUseDefaultTypeInternal;
extern PredictResponse_OutputsEntry_DoNotUseDefaultTypeInternal _PredictResponse_OutputsEntry_DoNotUse_default_instance_;
}  // namespace serving
}  // namespace adlik
PROTOBUF_NAMESPACE_OPEN
template<> ::adlik::serving::PredictRequest* Arena::CreateMaybeMessage<::adlik::serving::PredictRequest>(Arena*);
template<> ::adlik::serving::PredictRequest_Class* Arena::CreateMaybeMessage<::adlik::serving::PredictRequest_Class>(Arena*);
template<> ::adlik::serving::PredictRequest_InputsEntry_DoNotUse* Arena::CreateMaybeMessage<::adlik::serving::PredictRequest_InputsEntry_DoNotUse>(Arena*);
template<> ::adlik::serving::PredictRequest_Output* Arena::CreateMaybeMessage<::adlik::serving::PredictRequest_Output>(Arena*);
template<> ::adlik::serving::PredictRequest_OutputFilterEntry_DoNotUse* Arena::CreateMaybeMessage<::adlik::serving::PredictRequest_OutputFilterEntry_DoNotUse>(Arena*);
template<> ::adlik::serving::PredictResponse* Arena::CreateMaybeMessage<::adlik::serving::PredictResponse>(Arena*);
template<> ::adlik::serving::PredictResponse_Class* Arena::CreateMaybeMessage<::adlik::serving::PredictResponse_Class>(Arena*);
template<> ::adlik::serving::PredictResponse_Classes* Arena::CreateMaybeMessage<::adlik::serving::PredictResponse_Classes>(Arena*);
template<> ::adlik::serving::PredictResponse_Output* Arena::CreateMaybeMessage<::adlik::serving::PredictResponse_Output>(Arena*);
template<> ::adlik::serving::PredictResponse_OutputsEntry_DoNotUse* Arena::CreateMaybeMessage<::adlik::serving::PredictResponse_OutputsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace adlik {
namespace serving {

// ===================================================================

class PredictRequest_InputsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PredictRequest_InputsEntry_DoNotUse, 
    std::string, ::tensorflow::TensorProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PredictRequest_InputsEntry_DoNotUse, 
    std::string, ::tensorflow::TensorProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  PredictRequest_InputsEntry_DoNotUse();
  PredictRequest_InputsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PredictRequest_InputsEntry_DoNotUse& other);
  static const PredictRequest_InputsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PredictRequest_InputsEntry_DoNotUse*>(&_PredictRequest_InputsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "adlik.serving.PredictRequest.InputsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[0];
  }

  public:
};

// -------------------------------------------------------------------

class PredictRequest_Class :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.PredictRequest.Class) */ {
 public:
  PredictRequest_Class();
  virtual ~PredictRequest_Class();

  PredictRequest_Class(const PredictRequest_Class& from);
  PredictRequest_Class(PredictRequest_Class&& from) noexcept
    : PredictRequest_Class() {
    *this = ::std::move(from);
  }

  inline PredictRequest_Class& operator=(const PredictRequest_Class& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictRequest_Class& operator=(PredictRequest_Class&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PredictRequest_Class& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictRequest_Class* internal_default_instance() {
    return reinterpret_cast<const PredictRequest_Class*>(
               &_PredictRequest_Class_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PredictRequest_Class& a, PredictRequest_Class& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictRequest_Class* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictRequest_Class* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictRequest_Class* New() const final {
    return CreateMaybeMessage<PredictRequest_Class>(nullptr);
  }

  PredictRequest_Class* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictRequest_Class>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PredictRequest_Class& from);
  void MergeFrom(const PredictRequest_Class& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictRequest_Class* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.PredictRequest.Class";
  }
  protected:
  explicit PredictRequest_Class(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // uint32 count = 1;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:adlik.serving.PredictRequest.Class)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fapis_2fpredict_2eproto;
};
// -------------------------------------------------------------------

class PredictRequest_Output :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.PredictRequest.Output) */ {
 public:
  PredictRequest_Output();
  virtual ~PredictRequest_Output();

  PredictRequest_Output(const PredictRequest_Output& from);
  PredictRequest_Output(PredictRequest_Output&& from) noexcept
    : PredictRequest_Output() {
    *this = ::std::move(from);
  }

  inline PredictRequest_Output& operator=(const PredictRequest_Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictRequest_Output& operator=(PredictRequest_Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PredictRequest_Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictRequest_Output* internal_default_instance() {
    return reinterpret_cast<const PredictRequest_Output*>(
               &_PredictRequest_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PredictRequest_Output& a, PredictRequest_Output& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictRequest_Output* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictRequest_Output* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictRequest_Output* New() const final {
    return CreateMaybeMessage<PredictRequest_Output>(nullptr);
  }

  PredictRequest_Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictRequest_Output>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PredictRequest_Output& from);
  void MergeFrom(const PredictRequest_Output& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictRequest_Output* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.PredictRequest.Output";
  }
  protected:
  explicit PredictRequest_Output(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClsFieldNumber = 1,
  };
  // .adlik.serving.PredictRequest.Class cls = 1;
  bool has_cls() const;
  void clear_cls();
  const ::adlik::serving::PredictRequest_Class& cls() const;
  ::adlik::serving::PredictRequest_Class* release_cls();
  ::adlik::serving::PredictRequest_Class* mutable_cls();
  void set_allocated_cls(::adlik::serving::PredictRequest_Class* cls);
  void unsafe_arena_set_allocated_cls(
      ::adlik::serving::PredictRequest_Class* cls);
  ::adlik::serving::PredictRequest_Class* unsafe_arena_release_cls();

  // @@protoc_insertion_point(class_scope:adlik.serving.PredictRequest.Output)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::adlik::serving::PredictRequest_Class* cls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fapis_2fpredict_2eproto;
};
// -------------------------------------------------------------------

class PredictRequest_OutputFilterEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PredictRequest_OutputFilterEntry_DoNotUse, 
    std::string, ::adlik::serving::PredictRequest_Output,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PredictRequest_OutputFilterEntry_DoNotUse, 
    std::string, ::adlik::serving::PredictRequest_Output,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  PredictRequest_OutputFilterEntry_DoNotUse();
  PredictRequest_OutputFilterEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PredictRequest_OutputFilterEntry_DoNotUse& other);
  static const PredictRequest_OutputFilterEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PredictRequest_OutputFilterEntry_DoNotUse*>(&_PredictRequest_OutputFilterEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "adlik.serving.PredictRequest.OutputFilterEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class PredictRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.PredictRequest) */ {
 public:
  PredictRequest();
  virtual ~PredictRequest();

  PredictRequest(const PredictRequest& from);
  PredictRequest(PredictRequest&& from) noexcept
    : PredictRequest() {
    *this = ::std::move(from);
  }

  inline PredictRequest& operator=(const PredictRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictRequest& operator=(PredictRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PredictRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictRequest* internal_default_instance() {
    return reinterpret_cast<const PredictRequest*>(
               &_PredictRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PredictRequest& a, PredictRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictRequest* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictRequest* New() const final {
    return CreateMaybeMessage<PredictRequest>(nullptr);
  }

  PredictRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PredictRequest& from);
  void MergeFrom(const PredictRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.PredictRequest";
  }
  protected:
  explicit PredictRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PredictRequest_Class Class;
  typedef PredictRequest_Output Output;

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 2,
    kOutputFilterFieldNumber = 4,
    kModelSpecFieldNumber = 1,
    kBatchSizeFieldNumber = 3,
  };
  // map<string, .tensorflow.TensorProto> inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tensorflow::TensorProto >&
      inputs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tensorflow::TensorProto >*
      mutable_inputs();

  // map<string, .adlik.serving.PredictRequest.Output> output_filter = 4;
  int output_filter_size() const;
  void clear_output_filter();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::adlik::serving::PredictRequest_Output >&
      output_filter() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::adlik::serving::PredictRequest_Output >*
      mutable_output_filter();

  // .adlik.serving.ModelSpec model_spec = 1;
  bool has_model_spec() const;
  void clear_model_spec();
  const ::adlik::serving::ModelSpec& model_spec() const;
  ::adlik::serving::ModelSpec* release_model_spec();
  ::adlik::serving::ModelSpec* mutable_model_spec();
  void set_allocated_model_spec(::adlik::serving::ModelSpec* model_spec);
  void unsafe_arena_set_allocated_model_spec(
      ::adlik::serving::ModelSpec* model_spec);
  ::adlik::serving::ModelSpec* unsafe_arena_release_model_spec();

  // uint32 batch_size = 3;
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:adlik.serving.PredictRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PredictRequest_InputsEntry_DoNotUse,
      std::string, ::tensorflow::TensorProto,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > inputs_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PredictRequest_OutputFilterEntry_DoNotUse,
      std::string, ::adlik::serving::PredictRequest_Output,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > output_filter_;
  ::adlik::serving::ModelSpec* model_spec_;
  ::PROTOBUF_NAMESPACE_ID::uint32 batch_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fapis_2fpredict_2eproto;
};
// -------------------------------------------------------------------

class PredictResponse_Class :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.PredictResponse.Class) */ {
 public:
  PredictResponse_Class();
  virtual ~PredictResponse_Class();

  PredictResponse_Class(const PredictResponse_Class& from);
  PredictResponse_Class(PredictResponse_Class&& from) noexcept
    : PredictResponse_Class() {
    *this = ::std::move(from);
  }

  inline PredictResponse_Class& operator=(const PredictResponse_Class& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictResponse_Class& operator=(PredictResponse_Class&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PredictResponse_Class& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictResponse_Class* internal_default_instance() {
    return reinterpret_cast<const PredictResponse_Class*>(
               &_PredictResponse_Class_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PredictResponse_Class& a, PredictResponse_Class& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictResponse_Class* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictResponse_Class* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictResponse_Class* New() const final {
    return CreateMaybeMessage<PredictResponse_Class>(nullptr);
  }

  PredictResponse_Class* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictResponse_Class>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PredictResponse_Class& from);
  void MergeFrom(const PredictResponse_Class& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictResponse_Class* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.PredictResponse.Class";
  }
  protected:
  explicit PredictResponse_Class(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 3,
    kIdxFieldNumber = 1,
    kScoreFieldNumber = 2,
  };
  // string label = 3;
  void clear_label();
  const std::string& label() const;
  void set_label(const std::string& value);
  void set_label(std::string&& value);
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  std::string* mutable_label();
  std::string* release_label();
  void set_allocated_label(std::string* label);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_label();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_label(
      std::string* label);

  // int32 idx = 1;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::int32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float score = 2;
  void clear_score();
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:adlik.serving.PredictResponse.Class)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::PROTOBUF_NAMESPACE_ID::int32 idx_;
  float score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fapis_2fpredict_2eproto;
};
// -------------------------------------------------------------------

class PredictResponse_Classes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.PredictResponse.Classes) */ {
 public:
  PredictResponse_Classes();
  virtual ~PredictResponse_Classes();

  PredictResponse_Classes(const PredictResponse_Classes& from);
  PredictResponse_Classes(PredictResponse_Classes&& from) noexcept
    : PredictResponse_Classes() {
    *this = ::std::move(from);
  }

  inline PredictResponse_Classes& operator=(const PredictResponse_Classes& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictResponse_Classes& operator=(PredictResponse_Classes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PredictResponse_Classes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictResponse_Classes* internal_default_instance() {
    return reinterpret_cast<const PredictResponse_Classes*>(
               &_PredictResponse_Classes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PredictResponse_Classes& a, PredictResponse_Classes& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictResponse_Classes* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictResponse_Classes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictResponse_Classes* New() const final {
    return CreateMaybeMessage<PredictResponse_Classes>(nullptr);
  }

  PredictResponse_Classes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictResponse_Classes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PredictResponse_Classes& from);
  void MergeFrom(const PredictResponse_Classes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictResponse_Classes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.PredictResponse.Classes";
  }
  protected:
  explicit PredictResponse_Classes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClsFieldNumber = 1,
  };
  // repeated .adlik.serving.PredictResponse.Class cls = 1;
  int cls_size() const;
  void clear_cls();
  ::adlik::serving::PredictResponse_Class* mutable_cls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Class >*
      mutable_cls();
  const ::adlik::serving::PredictResponse_Class& cls(int index) const;
  ::adlik::serving::PredictResponse_Class* add_cls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Class >&
      cls() const;

  // @@protoc_insertion_point(class_scope:adlik.serving.PredictResponse.Classes)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Class > cls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fapis_2fpredict_2eproto;
};
// -------------------------------------------------------------------

class PredictResponse_Output :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.PredictResponse.Output) */ {
 public:
  PredictResponse_Output();
  virtual ~PredictResponse_Output();

  PredictResponse_Output(const PredictResponse_Output& from);
  PredictResponse_Output(PredictResponse_Output&& from) noexcept
    : PredictResponse_Output() {
    *this = ::std::move(from);
  }

  inline PredictResponse_Output& operator=(const PredictResponse_Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictResponse_Output& operator=(PredictResponse_Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PredictResponse_Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictResponse_Output* internal_default_instance() {
    return reinterpret_cast<const PredictResponse_Output*>(
               &_PredictResponse_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PredictResponse_Output& a, PredictResponse_Output& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictResponse_Output* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictResponse_Output* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictResponse_Output* New() const final {
    return CreateMaybeMessage<PredictResponse_Output>(nullptr);
  }

  PredictResponse_Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictResponse_Output>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PredictResponse_Output& from);
  void MergeFrom(const PredictResponse_Output& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictResponse_Output* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.PredictResponse.Output";
  }
  protected:
  explicit PredictResponse_Output(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchClassesFieldNumber = 2,
    kTensorFieldNumber = 1,
  };
  // repeated .adlik.serving.PredictResponse.Classes batch_classes = 2;
  int batch_classes_size() const;
  void clear_batch_classes();
  ::adlik::serving::PredictResponse_Classes* mutable_batch_classes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Classes >*
      mutable_batch_classes();
  const ::adlik::serving::PredictResponse_Classes& batch_classes(int index) const;
  ::adlik::serving::PredictResponse_Classes* add_batch_classes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Classes >&
      batch_classes() const;

  // .tensorflow.TensorProto tensor = 1;
  bool has_tensor() const;
  void clear_tensor();
  const ::tensorflow::TensorProto& tensor() const;
  ::tensorflow::TensorProto* release_tensor();
  ::tensorflow::TensorProto* mutable_tensor();
  void set_allocated_tensor(::tensorflow::TensorProto* tensor);
  void unsafe_arena_set_allocated_tensor(
      ::tensorflow::TensorProto* tensor);
  ::tensorflow::TensorProto* unsafe_arena_release_tensor();

  // @@protoc_insertion_point(class_scope:adlik.serving.PredictResponse.Output)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Classes > batch_classes_;
  ::tensorflow::TensorProto* tensor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fapis_2fpredict_2eproto;
};
// -------------------------------------------------------------------

class PredictResponse_OutputsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PredictResponse_OutputsEntry_DoNotUse, 
    std::string, ::adlik::serving::PredictResponse_Output,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PredictResponse_OutputsEntry_DoNotUse, 
    std::string, ::adlik::serving::PredictResponse_Output,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  PredictResponse_OutputsEntry_DoNotUse();
  PredictResponse_OutputsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PredictResponse_OutputsEntry_DoNotUse& other);
  static const PredictResponse_OutputsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PredictResponse_OutputsEntry_DoNotUse*>(&_PredictResponse_OutputsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "adlik.serving.PredictResponse.OutputsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[8];
  }

  public:
};

// -------------------------------------------------------------------

class PredictResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.PredictResponse) */ {
 public:
  PredictResponse();
  virtual ~PredictResponse();

  PredictResponse(const PredictResponse& from);
  PredictResponse(PredictResponse&& from) noexcept
    : PredictResponse() {
    *this = ::std::move(from);
  }

  inline PredictResponse& operator=(const PredictResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictResponse& operator=(PredictResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PredictResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictResponse* internal_default_instance() {
    return reinterpret_cast<const PredictResponse*>(
               &_PredictResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PredictResponse& a, PredictResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictResponse* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictResponse* New() const final {
    return CreateMaybeMessage<PredictResponse>(nullptr);
  }

  PredictResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PredictResponse& from);
  void MergeFrom(const PredictResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.PredictResponse";
  }
  protected:
  explicit PredictResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto);
    return ::descriptor_table_adlik_5fserving_2fapis_2fpredict_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PredictResponse_Class Class;
  typedef PredictResponse_Classes Classes;
  typedef PredictResponse_Output Output;

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 2,
    kModelSpecFieldNumber = 1,
  };
  // map<string, .adlik.serving.PredictResponse.Output> outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::adlik::serving::PredictResponse_Output >&
      outputs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::adlik::serving::PredictResponse_Output >*
      mutable_outputs();

  // .adlik.serving.ModelSpec model_spec = 1;
  bool has_model_spec() const;
  void clear_model_spec();
  const ::adlik::serving::ModelSpec& model_spec() const;
  ::adlik::serving::ModelSpec* release_model_spec();
  ::adlik::serving::ModelSpec* mutable_model_spec();
  void set_allocated_model_spec(::adlik::serving::ModelSpec* model_spec);
  void unsafe_arena_set_allocated_model_spec(
      ::adlik::serving::ModelSpec* model_spec);
  ::adlik::serving::ModelSpec* unsafe_arena_release_model_spec();

  // @@protoc_insertion_point(class_scope:adlik.serving.PredictResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PredictResponse_OutputsEntry_DoNotUse,
      std::string, ::adlik::serving::PredictResponse_Output,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > outputs_;
  ::adlik::serving::ModelSpec* model_spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fapis_2fpredict_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PredictRequest_Class

// uint32 count = 1;
inline void PredictRequest_Class::clear_count() {
  count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PredictRequest_Class::count() const {
  // @@protoc_insertion_point(field_get:adlik.serving.PredictRequest.Class.count)
  return count_;
}
inline void PredictRequest_Class::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.PredictRequest.Class.count)
}

// -------------------------------------------------------------------

// PredictRequest_Output

// .adlik.serving.PredictRequest.Class cls = 1;
inline bool PredictRequest_Output::has_cls() const {
  return this != internal_default_instance() && cls_ != nullptr;
}
inline void PredictRequest_Output::clear_cls() {
  if (GetArenaNoVirtual() == nullptr && cls_ != nullptr) {
    delete cls_;
  }
  cls_ = nullptr;
}
inline const ::adlik::serving::PredictRequest_Class& PredictRequest_Output::cls() const {
  const ::adlik::serving::PredictRequest_Class* p = cls_;
  // @@protoc_insertion_point(field_get:adlik.serving.PredictRequest.Output.cls)
  return p != nullptr ? *p : *reinterpret_cast<const ::adlik::serving::PredictRequest_Class*>(
      &::adlik::serving::_PredictRequest_Class_default_instance_);
}
inline ::adlik::serving::PredictRequest_Class* PredictRequest_Output::release_cls() {
  // @@protoc_insertion_point(field_release:adlik.serving.PredictRequest.Output.cls)
  
  ::adlik::serving::PredictRequest_Class* temp = cls_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  cls_ = nullptr;
  return temp;
}
inline ::adlik::serving::PredictRequest_Class* PredictRequest_Output::unsafe_arena_release_cls() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.PredictRequest.Output.cls)
  
  ::adlik::serving::PredictRequest_Class* temp = cls_;
  cls_ = nullptr;
  return temp;
}
inline ::adlik::serving::PredictRequest_Class* PredictRequest_Output::mutable_cls() {
  
  if (cls_ == nullptr) {
    auto* p = CreateMaybeMessage<::adlik::serving::PredictRequest_Class>(GetArenaNoVirtual());
    cls_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adlik.serving.PredictRequest.Output.cls)
  return cls_;
}
inline void PredictRequest_Output::set_allocated_cls(::adlik::serving::PredictRequest_Class* cls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cls_;
  }
  if (cls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cls);
    if (message_arena != submessage_arena) {
      cls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cls, submessage_arena);
    }
    
  } else {
    
  }
  cls_ = cls;
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.PredictRequest.Output.cls)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PredictRequest

// .adlik.serving.ModelSpec model_spec = 1;
inline bool PredictRequest::has_model_spec() const {
  return this != internal_default_instance() && model_spec_ != nullptr;
}
inline const ::adlik::serving::ModelSpec& PredictRequest::model_spec() const {
  const ::adlik::serving::ModelSpec* p = model_spec_;
  // @@protoc_insertion_point(field_get:adlik.serving.PredictRequest.model_spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::adlik::serving::ModelSpec*>(
      &::adlik::serving::_ModelSpec_default_instance_);
}
inline ::adlik::serving::ModelSpec* PredictRequest::release_model_spec() {
  // @@protoc_insertion_point(field_release:adlik.serving.PredictRequest.model_spec)
  
  ::adlik::serving::ModelSpec* temp = model_spec_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  model_spec_ = nullptr;
  return temp;
}
inline ::adlik::serving::ModelSpec* PredictRequest::unsafe_arena_release_model_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.PredictRequest.model_spec)
  
  ::adlik::serving::ModelSpec* temp = model_spec_;
  model_spec_ = nullptr;
  return temp;
}
inline ::adlik::serving::ModelSpec* PredictRequest::mutable_model_spec() {
  
  if (model_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::adlik::serving::ModelSpec>(GetArenaNoVirtual());
    model_spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adlik.serving.PredictRequest.model_spec)
  return model_spec_;
}
inline void PredictRequest::set_allocated_model_spec(::adlik::serving::ModelSpec* model_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_spec_);
  }
  if (model_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_spec)->GetArena();
    if (message_arena != submessage_arena) {
      model_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_spec, submessage_arena);
    }
    
  } else {
    
  }
  model_spec_ = model_spec;
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.PredictRequest.model_spec)
}

// map<string, .tensorflow.TensorProto> inputs = 2;
inline int PredictRequest::inputs_size() const {
  return inputs_.size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tensorflow::TensorProto >&
PredictRequest::inputs() const {
  // @@protoc_insertion_point(field_map:adlik.serving.PredictRequest.inputs)
  return inputs_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tensorflow::TensorProto >*
PredictRequest::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_map:adlik.serving.PredictRequest.inputs)
  return inputs_.MutableMap();
}

// uint32 batch_size = 3;
inline void PredictRequest::clear_batch_size() {
  batch_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PredictRequest::batch_size() const {
  // @@protoc_insertion_point(field_get:adlik.serving.PredictRequest.batch_size)
  return batch_size_;
}
inline void PredictRequest::set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.PredictRequest.batch_size)
}

// map<string, .adlik.serving.PredictRequest.Output> output_filter = 4;
inline int PredictRequest::output_filter_size() const {
  return output_filter_.size();
}
inline void PredictRequest::clear_output_filter() {
  output_filter_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::adlik::serving::PredictRequest_Output >&
PredictRequest::output_filter() const {
  // @@protoc_insertion_point(field_map:adlik.serving.PredictRequest.output_filter)
  return output_filter_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::adlik::serving::PredictRequest_Output >*
PredictRequest::mutable_output_filter() {
  // @@protoc_insertion_point(field_mutable_map:adlik.serving.PredictRequest.output_filter)
  return output_filter_.MutableMap();
}

// -------------------------------------------------------------------

// PredictResponse_Class

// int32 idx = 1;
inline void PredictResponse_Class::clear_idx() {
  idx_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PredictResponse_Class::idx() const {
  // @@protoc_insertion_point(field_get:adlik.serving.PredictResponse.Class.idx)
  return idx_;
}
inline void PredictResponse_Class::set_idx(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  idx_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.PredictResponse.Class.idx)
}

// float score = 2;
inline void PredictResponse_Class::clear_score() {
  score_ = 0;
}
inline float PredictResponse_Class::score() const {
  // @@protoc_insertion_point(field_get:adlik.serving.PredictResponse.Class.score)
  return score_;
}
inline void PredictResponse_Class::set_score(float value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.PredictResponse.Class.score)
}

// string label = 3;
inline void PredictResponse_Class::clear_label() {
  label_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& PredictResponse_Class::label() const {
  // @@protoc_insertion_point(field_get:adlik.serving.PredictResponse.Class.label)
  return label_.Get();
}
inline void PredictResponse_Class::set_label(const std::string& value) {
  
  label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:adlik.serving.PredictResponse.Class.label)
}
inline void PredictResponse_Class::set_label(std::string&& value) {
  
  label_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:adlik.serving.PredictResponse.Class.label)
}
inline void PredictResponse_Class::set_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:adlik.serving.PredictResponse.Class.label)
}
inline void PredictResponse_Class::set_label(const char* value,
    size_t size) {
  
  label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:adlik.serving.PredictResponse.Class.label)
}
inline std::string* PredictResponse_Class::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:adlik.serving.PredictResponse.Class.label)
  return label_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* PredictResponse_Class::release_label() {
  // @@protoc_insertion_point(field_release:adlik.serving.PredictResponse.Class.label)
  
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PredictResponse_Class::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.PredictResponse.Class.label)
}
inline std::string* PredictResponse_Class::unsafe_arena_release_label() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.PredictResponse.Class.label)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return label_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PredictResponse_Class::unsafe_arena_set_allocated_label(
    std::string* label) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (label != nullptr) {
    
  } else {
    
  }
  label_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      label, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:adlik.serving.PredictResponse.Class.label)
}

// -------------------------------------------------------------------

// PredictResponse_Classes

// repeated .adlik.serving.PredictResponse.Class cls = 1;
inline int PredictResponse_Classes::cls_size() const {
  return cls_.size();
}
inline void PredictResponse_Classes::clear_cls() {
  cls_.Clear();
}
inline ::adlik::serving::PredictResponse_Class* PredictResponse_Classes::mutable_cls(int index) {
  // @@protoc_insertion_point(field_mutable:adlik.serving.PredictResponse.Classes.cls)
  return cls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Class >*
PredictResponse_Classes::mutable_cls() {
  // @@protoc_insertion_point(field_mutable_list:adlik.serving.PredictResponse.Classes.cls)
  return &cls_;
}
inline const ::adlik::serving::PredictResponse_Class& PredictResponse_Classes::cls(int index) const {
  // @@protoc_insertion_point(field_get:adlik.serving.PredictResponse.Classes.cls)
  return cls_.Get(index);
}
inline ::adlik::serving::PredictResponse_Class* PredictResponse_Classes::add_cls() {
  // @@protoc_insertion_point(field_add:adlik.serving.PredictResponse.Classes.cls)
  return cls_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Class >&
PredictResponse_Classes::cls() const {
  // @@protoc_insertion_point(field_list:adlik.serving.PredictResponse.Classes.cls)
  return cls_;
}

// -------------------------------------------------------------------

// PredictResponse_Output

// .tensorflow.TensorProto tensor = 1;
inline bool PredictResponse_Output::has_tensor() const {
  return this != internal_default_instance() && tensor_ != nullptr;
}
inline const ::tensorflow::TensorProto& PredictResponse_Output::tensor() const {
  const ::tensorflow::TensorProto* p = tensor_;
  // @@protoc_insertion_point(field_get:adlik.serving.PredictResponse.Output.tensor)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::TensorProto*>(
      &::tensorflow::_TensorProto_default_instance_);
}
inline ::tensorflow::TensorProto* PredictResponse_Output::release_tensor() {
  // @@protoc_insertion_point(field_release:adlik.serving.PredictResponse.Output.tensor)
  
  ::tensorflow::TensorProto* temp = tensor_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  tensor_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorProto* PredictResponse_Output::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.PredictResponse.Output.tensor)
  
  ::tensorflow::TensorProto* temp = tensor_;
  tensor_ = nullptr;
  return temp;
}
inline ::tensorflow::TensorProto* PredictResponse_Output::mutable_tensor() {
  
  if (tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::TensorProto>(GetArenaNoVirtual());
    tensor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adlik.serving.PredictResponse.Output.tensor)
  return tensor_;
}
inline void PredictResponse_Output::set_allocated_tensor(::tensorflow::TensorProto* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tensor_);
  }
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tensor)->GetArena();
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    
  } else {
    
  }
  tensor_ = tensor;
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.PredictResponse.Output.tensor)
}

// repeated .adlik.serving.PredictResponse.Classes batch_classes = 2;
inline int PredictResponse_Output::batch_classes_size() const {
  return batch_classes_.size();
}
inline void PredictResponse_Output::clear_batch_classes() {
  batch_classes_.Clear();
}
inline ::adlik::serving::PredictResponse_Classes* PredictResponse_Output::mutable_batch_classes(int index) {
  // @@protoc_insertion_point(field_mutable:adlik.serving.PredictResponse.Output.batch_classes)
  return batch_classes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Classes >*
PredictResponse_Output::mutable_batch_classes() {
  // @@protoc_insertion_point(field_mutable_list:adlik.serving.PredictResponse.Output.batch_classes)
  return &batch_classes_;
}
inline const ::adlik::serving::PredictResponse_Classes& PredictResponse_Output::batch_classes(int index) const {
  // @@protoc_insertion_point(field_get:adlik.serving.PredictResponse.Output.batch_classes)
  return batch_classes_.Get(index);
}
inline ::adlik::serving::PredictResponse_Classes* PredictResponse_Output::add_batch_classes() {
  // @@protoc_insertion_point(field_add:adlik.serving.PredictResponse.Output.batch_classes)
  return batch_classes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::PredictResponse_Classes >&
PredictResponse_Output::batch_classes() const {
  // @@protoc_insertion_point(field_list:adlik.serving.PredictResponse.Output.batch_classes)
  return batch_classes_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PredictResponse

// .adlik.serving.ModelSpec model_spec = 1;
inline bool PredictResponse::has_model_spec() const {
  return this != internal_default_instance() && model_spec_ != nullptr;
}
inline const ::adlik::serving::ModelSpec& PredictResponse::model_spec() const {
  const ::adlik::serving::ModelSpec* p = model_spec_;
  // @@protoc_insertion_point(field_get:adlik.serving.PredictResponse.model_spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::adlik::serving::ModelSpec*>(
      &::adlik::serving::_ModelSpec_default_instance_);
}
inline ::adlik::serving::ModelSpec* PredictResponse::release_model_spec() {
  // @@protoc_insertion_point(field_release:adlik.serving.PredictResponse.model_spec)
  
  ::adlik::serving::ModelSpec* temp = model_spec_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  model_spec_ = nullptr;
  return temp;
}
inline ::adlik::serving::ModelSpec* PredictResponse::unsafe_arena_release_model_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.PredictResponse.model_spec)
  
  ::adlik::serving::ModelSpec* temp = model_spec_;
  model_spec_ = nullptr;
  return temp;
}
inline ::adlik::serving::ModelSpec* PredictResponse::mutable_model_spec() {
  
  if (model_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::adlik::serving::ModelSpec>(GetArenaNoVirtual());
    model_spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adlik.serving.PredictResponse.model_spec)
  return model_spec_;
}
inline void PredictResponse::set_allocated_model_spec(::adlik::serving::ModelSpec* model_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_spec_);
  }
  if (model_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_spec)->GetArena();
    if (message_arena != submessage_arena) {
      model_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_spec, submessage_arena);
    }
    
  } else {
    
  }
  model_spec_ = model_spec;
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.PredictResponse.model_spec)
}

// map<string, .adlik.serving.PredictResponse.Output> outputs = 2;
inline int PredictResponse::outputs_size() const {
  return outputs_.size();
}
inline void PredictResponse::clear_outputs() {
  outputs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::adlik::serving::PredictResponse_Output >&
PredictResponse::outputs() const {
  // @@protoc_insertion_point(field_map:adlik.serving.PredictResponse.outputs)
  return outputs_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::adlik::serving::PredictResponse_Output >*
PredictResponse::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_map:adlik.serving.PredictResponse.outputs)
  return outputs_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace serving
}  // namespace adlik

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_adlik_5fserving_2fapis_2fpredict_2eproto
