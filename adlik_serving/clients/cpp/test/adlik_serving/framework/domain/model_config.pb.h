// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: adlik_serving/framework/domain/model_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "adlik_serving/framework/domain/version_policy.pb.h"
#include "tensorflow/core/framework/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto;
namespace adlik {
namespace serving {
class ModelConfigProto;
class ModelConfigProtoDefaultTypeInternal;
extern ModelConfigProtoDefaultTypeInternal _ModelConfigProto_default_instance_;
class ModelDynamicBatching;
class ModelDynamicBatchingDefaultTypeInternal;
extern ModelDynamicBatchingDefaultTypeInternal _ModelDynamicBatching_default_instance_;
class ModelInput;
class ModelInputDefaultTypeInternal;
extern ModelInputDefaultTypeInternal _ModelInput_default_instance_;
class ModelInstanceGroup;
class ModelInstanceGroupDefaultTypeInternal;
extern ModelInstanceGroupDefaultTypeInternal _ModelInstanceGroup_default_instance_;
class ModelOutput;
class ModelOutputDefaultTypeInternal;
extern ModelOutputDefaultTypeInternal _ModelOutput_default_instance_;
}  // namespace serving
}  // namespace adlik
PROTOBUF_NAMESPACE_OPEN
template<> ::adlik::serving::ModelConfigProto* Arena::CreateMaybeMessage<::adlik::serving::ModelConfigProto>(Arena*);
template<> ::adlik::serving::ModelDynamicBatching* Arena::CreateMaybeMessage<::adlik::serving::ModelDynamicBatching>(Arena*);
template<> ::adlik::serving::ModelInput* Arena::CreateMaybeMessage<::adlik::serving::ModelInput>(Arena*);
template<> ::adlik::serving::ModelInstanceGroup* Arena::CreateMaybeMessage<::adlik::serving::ModelInstanceGroup>(Arena*);
template<> ::adlik::serving::ModelOutput* Arena::CreateMaybeMessage<::adlik::serving::ModelOutput>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace adlik {
namespace serving {

enum ModelInstanceGroup_Kind : int {
  ModelInstanceGroup_Kind_KIND_AUTO = 0,
  ModelInstanceGroup_Kind_KIND_GPU = 1,
  ModelInstanceGroup_Kind_KIND_CPU = 2,
  ModelInstanceGroup_Kind_ModelInstanceGroup_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelInstanceGroup_Kind_ModelInstanceGroup_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelInstanceGroup_Kind_IsValid(int value);
constexpr ModelInstanceGroup_Kind ModelInstanceGroup_Kind_Kind_MIN = ModelInstanceGroup_Kind_KIND_AUTO;
constexpr ModelInstanceGroup_Kind ModelInstanceGroup_Kind_Kind_MAX = ModelInstanceGroup_Kind_KIND_CPU;
constexpr int ModelInstanceGroup_Kind_Kind_ARRAYSIZE = ModelInstanceGroup_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInstanceGroup_Kind_descriptor();
template<typename T>
inline const std::string& ModelInstanceGroup_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelInstanceGroup_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelInstanceGroup_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelInstanceGroup_Kind_descriptor(), enum_t_value);
}
inline bool ModelInstanceGroup_Kind_Parse(
    const std::string& name, ModelInstanceGroup_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelInstanceGroup_Kind>(
    ModelInstanceGroup_Kind_descriptor(), name, value);
}
enum ModelInput_Format : int {
  ModelInput_Format_FORMAT_NONE = 0,
  ModelInput_Format_FORMAT_NHWC = 1,
  ModelInput_Format_FORMAT_NCHW = 2,
  ModelInput_Format_ModelInput_Format_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelInput_Format_ModelInput_Format_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelInput_Format_IsValid(int value);
constexpr ModelInput_Format ModelInput_Format_Format_MIN = ModelInput_Format_FORMAT_NONE;
constexpr ModelInput_Format ModelInput_Format_Format_MAX = ModelInput_Format_FORMAT_NCHW;
constexpr int ModelInput_Format_Format_ARRAYSIZE = ModelInput_Format_Format_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelInput_Format_descriptor();
template<typename T>
inline const std::string& ModelInput_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelInput_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelInput_Format_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelInput_Format_descriptor(), enum_t_value);
}
inline bool ModelInput_Format_Parse(
    const std::string& name, ModelInput_Format* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelInput_Format>(
    ModelInput_Format_descriptor(), name, value);
}
// ===================================================================

class ModelInstanceGroup :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.ModelInstanceGroup) */ {
 public:
  ModelInstanceGroup();
  virtual ~ModelInstanceGroup();

  ModelInstanceGroup(const ModelInstanceGroup& from);
  ModelInstanceGroup(ModelInstanceGroup&& from) noexcept
    : ModelInstanceGroup() {
    *this = ::std::move(from);
  }

  inline ModelInstanceGroup& operator=(const ModelInstanceGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInstanceGroup& operator=(ModelInstanceGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInstanceGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInstanceGroup* internal_default_instance() {
    return reinterpret_cast<const ModelInstanceGroup*>(
               &_ModelInstanceGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ModelInstanceGroup& a, ModelInstanceGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInstanceGroup* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInstanceGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInstanceGroup* New() const final {
    return CreateMaybeMessage<ModelInstanceGroup>(nullptr);
  }

  ModelInstanceGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInstanceGroup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInstanceGroup& from);
  void MergeFrom(const ModelInstanceGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInstanceGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.ModelInstanceGroup";
  }
  protected:
  explicit ModelInstanceGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto);
    return ::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelInstanceGroup_Kind Kind;
  static constexpr Kind KIND_AUTO =
    ModelInstanceGroup_Kind_KIND_AUTO;
  static constexpr Kind KIND_GPU =
    ModelInstanceGroup_Kind_KIND_GPU;
  static constexpr Kind KIND_CPU =
    ModelInstanceGroup_Kind_KIND_CPU;
  static inline bool Kind_IsValid(int value) {
    return ModelInstanceGroup_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    ModelInstanceGroup_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    ModelInstanceGroup_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    ModelInstanceGroup_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return ModelInstanceGroup_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return ModelInstanceGroup_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(const std::string& name,
      Kind* value) {
    return ModelInstanceGroup_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGpusFieldNumber = 3,
    kNameFieldNumber = 1,
    kCountFieldNumber = 2,
    kKindFieldNumber = 4,
  };
  // repeated int32 gpus = 3;
  int gpus_size() const;
  void clear_gpus();
  ::PROTOBUF_NAMESPACE_ID::int32 gpus(int index) const;
  void set_gpus(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_gpus(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      gpus() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_gpus();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);

  // int32 count = 2;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .adlik.serving.ModelInstanceGroup.Kind kind = 4;
  void clear_kind();
  ::adlik::serving::ModelInstanceGroup_Kind kind() const;
  void set_kind(::adlik::serving::ModelInstanceGroup_Kind value);

  // @@protoc_insertion_point(class_scope:adlik.serving.ModelInstanceGroup)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > gpus_;
  mutable std::atomic<int> _gpus_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  int kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelInput :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.ModelInput) */ {
 public:
  ModelInput();
  virtual ~ModelInput();

  ModelInput(const ModelInput& from);
  ModelInput(ModelInput&& from) noexcept
    : ModelInput() {
    *this = ::std::move(from);
  }

  inline ModelInput& operator=(const ModelInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInput& operator=(ModelInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInput* internal_default_instance() {
    return reinterpret_cast<const ModelInput*>(
               &_ModelInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ModelInput& a, ModelInput& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInput* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInput* New() const final {
    return CreateMaybeMessage<ModelInput>(nullptr);
  }

  ModelInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInput& from);
  void MergeFrom(const ModelInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.ModelInput";
  }
  protected:
  explicit ModelInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto);
    return ::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelInput_Format Format;
  static constexpr Format FORMAT_NONE =
    ModelInput_Format_FORMAT_NONE;
  static constexpr Format FORMAT_NHWC =
    ModelInput_Format_FORMAT_NHWC;
  static constexpr Format FORMAT_NCHW =
    ModelInput_Format_FORMAT_NCHW;
  static inline bool Format_IsValid(int value) {
    return ModelInput_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    ModelInput_Format_Format_MIN;
  static constexpr Format Format_MAX =
    ModelInput_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    ModelInput_Format_Format_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Format_descriptor() {
    return ModelInput_Format_descriptor();
  }
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return ModelInput_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(const std::string& name,
      Format* value) {
    return ModelInput_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 4,
    kNameFieldNumber = 1,
    kDataTypeFieldNumber = 2,
    kFormatFieldNumber = 3,
  };
  // repeated int64 dims = 4;
  int dims_size() const;
  void clear_dims();
  ::PROTOBUF_NAMESPACE_ID::int64 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dims();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);

  // .tensorflow.DataType data_type = 2;
  void clear_data_type();
  ::tensorflow::DataType data_type() const;
  void set_data_type(::tensorflow::DataType value);

  // .adlik.serving.ModelInput.Format format = 3;
  void clear_format();
  ::adlik::serving::ModelInput_Format format() const;
  void set_format(::adlik::serving::ModelInput_Format value);

  // @@protoc_insertion_point(class_scope:adlik.serving.ModelInput)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dims_;
  mutable std::atomic<int> _dims_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int data_type_;
  int format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelOutput :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.ModelOutput) */ {
 public:
  ModelOutput();
  virtual ~ModelOutput();

  ModelOutput(const ModelOutput& from);
  ModelOutput(ModelOutput&& from) noexcept
    : ModelOutput() {
    *this = ::std::move(from);
  }

  inline ModelOutput& operator=(const ModelOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelOutput& operator=(ModelOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelOutput* internal_default_instance() {
    return reinterpret_cast<const ModelOutput*>(
               &_ModelOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModelOutput& a, ModelOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelOutput* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelOutput* New() const final {
    return CreateMaybeMessage<ModelOutput>(nullptr);
  }

  ModelOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelOutput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelOutput& from);
  void MergeFrom(const ModelOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelOutput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.ModelOutput";
  }
  protected:
  explicit ModelOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto);
    return ::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 3,
    kNameFieldNumber = 1,
    kLabelFilenameFieldNumber = 4,
    kDataTypeFieldNumber = 2,
  };
  // repeated int64 dims = 3;
  int dims_size() const;
  void clear_dims();
  ::PROTOBUF_NAMESPACE_ID::int64 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dims();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);

  // string label_filename = 4;
  void clear_label_filename();
  const std::string& label_filename() const;
  void set_label_filename(const std::string& value);
  void set_label_filename(std::string&& value);
  void set_label_filename(const char* value);
  void set_label_filename(const char* value, size_t size);
  std::string* mutable_label_filename();
  std::string* release_label_filename();
  void set_allocated_label_filename(std::string* label_filename);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_label_filename();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_label_filename(
      std::string* label_filename);

  // .tensorflow.DataType data_type = 2;
  void clear_data_type();
  ::tensorflow::DataType data_type() const;
  void set_data_type(::tensorflow::DataType value);

  // @@protoc_insertion_point(class_scope:adlik.serving.ModelOutput)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dims_;
  mutable std::atomic<int> _dims_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_filename_;
  int data_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelDynamicBatching :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.ModelDynamicBatching) */ {
 public:
  ModelDynamicBatching();
  virtual ~ModelDynamicBatching();

  ModelDynamicBatching(const ModelDynamicBatching& from);
  ModelDynamicBatching(ModelDynamicBatching&& from) noexcept
    : ModelDynamicBatching() {
    *this = ::std::move(from);
  }

  inline ModelDynamicBatching& operator=(const ModelDynamicBatching& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelDynamicBatching& operator=(ModelDynamicBatching&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelDynamicBatching& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelDynamicBatching* internal_default_instance() {
    return reinterpret_cast<const ModelDynamicBatching*>(
               &_ModelDynamicBatching_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModelDynamicBatching& a, ModelDynamicBatching& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelDynamicBatching* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelDynamicBatching* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelDynamicBatching* New() const final {
    return CreateMaybeMessage<ModelDynamicBatching>(nullptr);
  }

  ModelDynamicBatching* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelDynamicBatching>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelDynamicBatching& from);
  void MergeFrom(const ModelDynamicBatching& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelDynamicBatching* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.ModelDynamicBatching";
  }
  protected:
  explicit ModelDynamicBatching(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto);
    return ::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreferredBatchSizeFieldNumber = 1,
    kMaxQueueDelayMicrosecondsFieldNumber = 2,
    kMaxEnqueuedBatchesFieldNumber = 3,
    kPadVariableLengthInputsFieldNumber = 7,
  };
  // repeated int32 preferred_batch_size = 1;
  int preferred_batch_size_size() const;
  void clear_preferred_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 preferred_batch_size(int index) const;
  void set_preferred_batch_size(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      preferred_batch_size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_preferred_batch_size();

  // int32 max_queue_delay_microseconds = 2;
  void clear_max_queue_delay_microseconds();
  ::PROTOBUF_NAMESPACE_ID::int32 max_queue_delay_microseconds() const;
  void set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 max_enqueued_batches = 3;
  void clear_max_enqueued_batches();
  ::PROTOBUF_NAMESPACE_ID::int32 max_enqueued_batches() const;
  void set_max_enqueued_batches(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool pad_variable_length_inputs = 7;
  void clear_pad_variable_length_inputs();
  bool pad_variable_length_inputs() const;
  void set_pad_variable_length_inputs(bool value);

  // @@protoc_insertion_point(class_scope:adlik.serving.ModelDynamicBatching)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > preferred_batch_size_;
  mutable std::atomic<int> _preferred_batch_size_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_queue_delay_microseconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_enqueued_batches_;
  bool pad_variable_length_inputs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ModelConfigProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adlik.serving.ModelConfigProto) */ {
 public:
  ModelConfigProto();
  virtual ~ModelConfigProto();

  ModelConfigProto(const ModelConfigProto& from);
  ModelConfigProto(ModelConfigProto&& from) noexcept
    : ModelConfigProto() {
    *this = ::std::move(from);
  }

  inline ModelConfigProto& operator=(const ModelConfigProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelConfigProto& operator=(ModelConfigProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelConfigProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelConfigProto* internal_default_instance() {
    return reinterpret_cast<const ModelConfigProto*>(
               &_ModelConfigProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModelConfigProto& a, ModelConfigProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelConfigProto* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelConfigProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelConfigProto* New() const final {
    return CreateMaybeMessage<ModelConfigProto>(nullptr);
  }

  ModelConfigProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelConfigProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelConfigProto& from);
  void MergeFrom(const ModelConfigProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelConfigProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adlik.serving.ModelConfigProto";
  }
  protected:
  explicit ModelConfigProto(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto);
    return ::descriptor_table_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 6,
    kOutputFieldNumber = 7,
    kInstanceGroupFieldNumber = 8,
    kNameFieldNumber = 1,
    kPlatformFieldNumber = 2,
    kPlatformVersionFieldNumber = 3,
    kAlgorithmFieldNumber = 20,
    kVersionPolicyFieldNumber = 4,
    kDynamicBatchingFieldNumber = 12,
    kMaxBatchSizeFieldNumber = 5,
  };
  // repeated .adlik.serving.ModelInput input = 6;
  int input_size() const;
  void clear_input();
  ::adlik::serving::ModelInput* mutable_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInput >*
      mutable_input();
  const ::adlik::serving::ModelInput& input(int index) const;
  ::adlik::serving::ModelInput* add_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInput >&
      input() const;

  // repeated .adlik.serving.ModelOutput output = 7;
  int output_size() const;
  void clear_output();
  ::adlik::serving::ModelOutput* mutable_output(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelOutput >*
      mutable_output();
  const ::adlik::serving::ModelOutput& output(int index) const;
  ::adlik::serving::ModelOutput* add_output();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelOutput >&
      output() const;

  // repeated .adlik.serving.ModelInstanceGroup instance_group = 8;
  int instance_group_size() const;
  void clear_instance_group();
  ::adlik::serving::ModelInstanceGroup* mutable_instance_group(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInstanceGroup >*
      mutable_instance_group();
  const ::adlik::serving::ModelInstanceGroup& instance_group(int index) const;
  ::adlik::serving::ModelInstanceGroup* add_instance_group();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInstanceGroup >&
      instance_group() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);

  // string platform = 2;
  void clear_platform();
  const std::string& platform() const;
  void set_platform(const std::string& value);
  void set_platform(std::string&& value);
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  std::string* mutable_platform();
  std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_platform();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_platform(
      std::string* platform);

  // string platform_version = 3;
  void clear_platform_version();
  const std::string& platform_version() const;
  void set_platform_version(const std::string& value);
  void set_platform_version(std::string&& value);
  void set_platform_version(const char* value);
  void set_platform_version(const char* value, size_t size);
  std::string* mutable_platform_version();
  std::string* release_platform_version();
  void set_allocated_platform_version(std::string* platform_version);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_platform_version();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_platform_version(
      std::string* platform_version);

  // string algorithm = 20;
  void clear_algorithm();
  const std::string& algorithm() const;
  void set_algorithm(const std::string& value);
  void set_algorithm(std::string&& value);
  void set_algorithm(const char* value);
  void set_algorithm(const char* value, size_t size);
  std::string* mutable_algorithm();
  std::string* release_algorithm();
  void set_allocated_algorithm(std::string* algorithm);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_algorithm();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_algorithm(
      std::string* algorithm);

  // .adlik.serving.VersionPolicyProto version_policy = 4;
  bool has_version_policy() const;
  void clear_version_policy();
  const ::adlik::serving::VersionPolicyProto& version_policy() const;
  ::adlik::serving::VersionPolicyProto* release_version_policy();
  ::adlik::serving::VersionPolicyProto* mutable_version_policy();
  void set_allocated_version_policy(::adlik::serving::VersionPolicyProto* version_policy);
  void unsafe_arena_set_allocated_version_policy(
      ::adlik::serving::VersionPolicyProto* version_policy);
  ::adlik::serving::VersionPolicyProto* unsafe_arena_release_version_policy();

  // .adlik.serving.ModelDynamicBatching dynamic_batching = 12;
  bool has_dynamic_batching() const;
  void clear_dynamic_batching();
  const ::adlik::serving::ModelDynamicBatching& dynamic_batching() const;
  ::adlik::serving::ModelDynamicBatching* release_dynamic_batching();
  ::adlik::serving::ModelDynamicBatching* mutable_dynamic_batching();
  void set_allocated_dynamic_batching(::adlik::serving::ModelDynamicBatching* dynamic_batching);
  void unsafe_arena_set_allocated_dynamic_batching(
      ::adlik::serving::ModelDynamicBatching* dynamic_batching);
  ::adlik::serving::ModelDynamicBatching* unsafe_arena_release_dynamic_batching();

  // int32 max_batch_size = 5;
  void clear_max_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_batch_size() const;
  void set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:adlik.serving.ModelConfigProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInput > input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelOutput > output_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInstanceGroup > instance_group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algorithm_;
  ::adlik::serving::VersionPolicyProto* version_policy_;
  ::adlik::serving::ModelDynamicBatching* dynamic_batching_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_batch_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModelInstanceGroup

// string name = 1;
inline void ModelInstanceGroup::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& ModelInstanceGroup::name() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelInstanceGroup.name)
  return name_.Get();
}
inline void ModelInstanceGroup::set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:adlik.serving.ModelInstanceGroup.name)
}
inline void ModelInstanceGroup::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:adlik.serving.ModelInstanceGroup.name)
}
inline void ModelInstanceGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:adlik.serving.ModelInstanceGroup.name)
}
inline void ModelInstanceGroup::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:adlik.serving.ModelInstanceGroup.name)
}
inline std::string* ModelInstanceGroup::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelInstanceGroup.name)
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* ModelInstanceGroup::release_name() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelInstanceGroup.name)
  
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ModelInstanceGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelInstanceGroup.name)
}
inline std::string* ModelInstanceGroup::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelInstanceGroup.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ModelInstanceGroup::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:adlik.serving.ModelInstanceGroup.name)
}

// .adlik.serving.ModelInstanceGroup.Kind kind = 4;
inline void ModelInstanceGroup::clear_kind() {
  kind_ = 0;
}
inline ::adlik::serving::ModelInstanceGroup_Kind ModelInstanceGroup::kind() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelInstanceGroup.kind)
  return static_cast< ::adlik::serving::ModelInstanceGroup_Kind >(kind_);
}
inline void ModelInstanceGroup::set_kind(::adlik::serving::ModelInstanceGroup_Kind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.ModelInstanceGroup.kind)
}

// int32 count = 2;
inline void ModelInstanceGroup::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelInstanceGroup::count() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelInstanceGroup.count)
  return count_;
}
inline void ModelInstanceGroup::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.ModelInstanceGroup.count)
}

// repeated int32 gpus = 3;
inline int ModelInstanceGroup::gpus_size() const {
  return gpus_.size();
}
inline void ModelInstanceGroup::clear_gpus() {
  gpus_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelInstanceGroup::gpus(int index) const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelInstanceGroup.gpus)
  return gpus_.Get(index);
}
inline void ModelInstanceGroup::set_gpus(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  gpus_.Set(index, value);
  // @@protoc_insertion_point(field_set:adlik.serving.ModelInstanceGroup.gpus)
}
inline void ModelInstanceGroup::add_gpus(::PROTOBUF_NAMESPACE_ID::int32 value) {
  gpus_.Add(value);
  // @@protoc_insertion_point(field_add:adlik.serving.ModelInstanceGroup.gpus)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelInstanceGroup::gpus() const {
  // @@protoc_insertion_point(field_list:adlik.serving.ModelInstanceGroup.gpus)
  return gpus_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelInstanceGroup::mutable_gpus() {
  // @@protoc_insertion_point(field_mutable_list:adlik.serving.ModelInstanceGroup.gpus)
  return &gpus_;
}

// -------------------------------------------------------------------

// ModelInput

// string name = 1;
inline void ModelInput::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& ModelInput::name() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelInput.name)
  return name_.Get();
}
inline void ModelInput::set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:adlik.serving.ModelInput.name)
}
inline void ModelInput::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:adlik.serving.ModelInput.name)
}
inline void ModelInput::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:adlik.serving.ModelInput.name)
}
inline void ModelInput::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:adlik.serving.ModelInput.name)
}
inline std::string* ModelInput::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelInput.name)
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* ModelInput::release_name() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelInput.name)
  
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ModelInput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelInput.name)
}
inline std::string* ModelInput::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelInput.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ModelInput::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:adlik.serving.ModelInput.name)
}

// .tensorflow.DataType data_type = 2;
inline void ModelInput::clear_data_type() {
  data_type_ = 0;
}
inline ::tensorflow::DataType ModelInput::data_type() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelInput.data_type)
  return static_cast< ::tensorflow::DataType >(data_type_);
}
inline void ModelInput::set_data_type(::tensorflow::DataType value) {
  
  data_type_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.ModelInput.data_type)
}

// .adlik.serving.ModelInput.Format format = 3;
inline void ModelInput::clear_format() {
  format_ = 0;
}
inline ::adlik::serving::ModelInput_Format ModelInput::format() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelInput.format)
  return static_cast< ::adlik::serving::ModelInput_Format >(format_);
}
inline void ModelInput::set_format(::adlik::serving::ModelInput_Format value) {
  
  format_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.ModelInput.format)
}

// repeated int64 dims = 4;
inline int ModelInput::dims_size() const {
  return dims_.size();
}
inline void ModelInput::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelInput::dims(int index) const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelInput.dims)
  return dims_.Get(index);
}
inline void ModelInput::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:adlik.serving.ModelInput.dims)
}
inline void ModelInput::add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:adlik.serving.ModelInput.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelInput::dims() const {
  // @@protoc_insertion_point(field_list:adlik.serving.ModelInput.dims)
  return dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelInput::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:adlik.serving.ModelInput.dims)
  return &dims_;
}

// -------------------------------------------------------------------

// ModelOutput

// string name = 1;
inline void ModelOutput::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& ModelOutput::name() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelOutput.name)
  return name_.Get();
}
inline void ModelOutput::set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:adlik.serving.ModelOutput.name)
}
inline void ModelOutput::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:adlik.serving.ModelOutput.name)
}
inline void ModelOutput::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:adlik.serving.ModelOutput.name)
}
inline void ModelOutput::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:adlik.serving.ModelOutput.name)
}
inline std::string* ModelOutput::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelOutput.name)
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* ModelOutput::release_name() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelOutput.name)
  
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ModelOutput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelOutput.name)
}
inline std::string* ModelOutput::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelOutput.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ModelOutput::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:adlik.serving.ModelOutput.name)
}

// .tensorflow.DataType data_type = 2;
inline void ModelOutput::clear_data_type() {
  data_type_ = 0;
}
inline ::tensorflow::DataType ModelOutput::data_type() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelOutput.data_type)
  return static_cast< ::tensorflow::DataType >(data_type_);
}
inline void ModelOutput::set_data_type(::tensorflow::DataType value) {
  
  data_type_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.ModelOutput.data_type)
}

// repeated int64 dims = 3;
inline int ModelOutput::dims_size() const {
  return dims_.size();
}
inline void ModelOutput::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelOutput::dims(int index) const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelOutput.dims)
  return dims_.Get(index);
}
inline void ModelOutput::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:adlik.serving.ModelOutput.dims)
}
inline void ModelOutput::add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:adlik.serving.ModelOutput.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ModelOutput::dims() const {
  // @@protoc_insertion_point(field_list:adlik.serving.ModelOutput.dims)
  return dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ModelOutput::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:adlik.serving.ModelOutput.dims)
  return &dims_;
}

// string label_filename = 4;
inline void ModelOutput::clear_label_filename() {
  label_filename_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& ModelOutput::label_filename() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelOutput.label_filename)
  return label_filename_.Get();
}
inline void ModelOutput::set_label_filename(const std::string& value) {
  
  label_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:adlik.serving.ModelOutput.label_filename)
}
inline void ModelOutput::set_label_filename(std::string&& value) {
  
  label_filename_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:adlik.serving.ModelOutput.label_filename)
}
inline void ModelOutput::set_label_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  label_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:adlik.serving.ModelOutput.label_filename)
}
inline void ModelOutput::set_label_filename(const char* value,
    size_t size) {
  
  label_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:adlik.serving.ModelOutput.label_filename)
}
inline std::string* ModelOutput::mutable_label_filename() {
  
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelOutput.label_filename)
  return label_filename_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* ModelOutput::release_label_filename() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelOutput.label_filename)
  
  return label_filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ModelOutput::set_allocated_label_filename(std::string* label_filename) {
  if (label_filename != nullptr) {
    
  } else {
    
  }
  label_filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label_filename,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelOutput.label_filename)
}
inline std::string* ModelOutput::unsafe_arena_release_label_filename() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelOutput.label_filename)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return label_filename_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ModelOutput::unsafe_arena_set_allocated_label_filename(
    std::string* label_filename) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (label_filename != nullptr) {
    
  } else {
    
  }
  label_filename_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      label_filename, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:adlik.serving.ModelOutput.label_filename)
}

// -------------------------------------------------------------------

// ModelDynamicBatching

// repeated int32 preferred_batch_size = 1;
inline int ModelDynamicBatching::preferred_batch_size_size() const {
  return preferred_batch_size_.size();
}
inline void ModelDynamicBatching::clear_preferred_batch_size() {
  preferred_batch_size_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelDynamicBatching::preferred_batch_size(int index) const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelDynamicBatching.preferred_batch_size)
  return preferred_batch_size_.Get(index);
}
inline void ModelDynamicBatching::set_preferred_batch_size(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  preferred_batch_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:adlik.serving.ModelDynamicBatching.preferred_batch_size)
}
inline void ModelDynamicBatching::add_preferred_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  preferred_batch_size_.Add(value);
  // @@protoc_insertion_point(field_add:adlik.serving.ModelDynamicBatching.preferred_batch_size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ModelDynamicBatching::preferred_batch_size() const {
  // @@protoc_insertion_point(field_list:adlik.serving.ModelDynamicBatching.preferred_batch_size)
  return preferred_batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ModelDynamicBatching::mutable_preferred_batch_size() {
  // @@protoc_insertion_point(field_mutable_list:adlik.serving.ModelDynamicBatching.preferred_batch_size)
  return &preferred_batch_size_;
}

// int32 max_queue_delay_microseconds = 2;
inline void ModelDynamicBatching::clear_max_queue_delay_microseconds() {
  max_queue_delay_microseconds_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelDynamicBatching::max_queue_delay_microseconds() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelDynamicBatching.max_queue_delay_microseconds)
  return max_queue_delay_microseconds_;
}
inline void ModelDynamicBatching::set_max_queue_delay_microseconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_queue_delay_microseconds_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.ModelDynamicBatching.max_queue_delay_microseconds)
}

// int32 max_enqueued_batches = 3;
inline void ModelDynamicBatching::clear_max_enqueued_batches() {
  max_enqueued_batches_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelDynamicBatching::max_enqueued_batches() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelDynamicBatching.max_enqueued_batches)
  return max_enqueued_batches_;
}
inline void ModelDynamicBatching::set_max_enqueued_batches(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_enqueued_batches_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.ModelDynamicBatching.max_enqueued_batches)
}

// bool pad_variable_length_inputs = 7;
inline void ModelDynamicBatching::clear_pad_variable_length_inputs() {
  pad_variable_length_inputs_ = false;
}
inline bool ModelDynamicBatching::pad_variable_length_inputs() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelDynamicBatching.pad_variable_length_inputs)
  return pad_variable_length_inputs_;
}
inline void ModelDynamicBatching::set_pad_variable_length_inputs(bool value) {
  
  pad_variable_length_inputs_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.ModelDynamicBatching.pad_variable_length_inputs)
}

// -------------------------------------------------------------------

// ModelConfigProto

// string name = 1;
inline void ModelConfigProto::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& ModelConfigProto::name() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.name)
  return name_.Get();
}
inline void ModelConfigProto::set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:adlik.serving.ModelConfigProto.name)
}
inline void ModelConfigProto::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:adlik.serving.ModelConfigProto.name)
}
inline void ModelConfigProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:adlik.serving.ModelConfigProto.name)
}
inline void ModelConfigProto::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:adlik.serving.ModelConfigProto.name)
}
inline std::string* ModelConfigProto::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelConfigProto.name)
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* ModelConfigProto::release_name() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelConfigProto.name)
  
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ModelConfigProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelConfigProto.name)
}
inline std::string* ModelConfigProto::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelConfigProto.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ModelConfigProto::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:adlik.serving.ModelConfigProto.name)
}

// string platform = 2;
inline void ModelConfigProto::clear_platform() {
  platform_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& ModelConfigProto::platform() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.platform)
  return platform_.Get();
}
inline void ModelConfigProto::set_platform(const std::string& value) {
  
  platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:adlik.serving.ModelConfigProto.platform)
}
inline void ModelConfigProto::set_platform(std::string&& value) {
  
  platform_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:adlik.serving.ModelConfigProto.platform)
}
inline void ModelConfigProto::set_platform(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:adlik.serving.ModelConfigProto.platform)
}
inline void ModelConfigProto::set_platform(const char* value,
    size_t size) {
  
  platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:adlik.serving.ModelConfigProto.platform)
}
inline std::string* ModelConfigProto::mutable_platform() {
  
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelConfigProto.platform)
  return platform_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* ModelConfigProto::release_platform() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelConfigProto.platform)
  
  return platform_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ModelConfigProto::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelConfigProto.platform)
}
inline std::string* ModelConfigProto::unsafe_arena_release_platform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelConfigProto.platform)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return platform_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ModelConfigProto::unsafe_arena_set_allocated_platform(
    std::string* platform) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      platform, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:adlik.serving.ModelConfigProto.platform)
}

// string platform_version = 3;
inline void ModelConfigProto::clear_platform_version() {
  platform_version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& ModelConfigProto::platform_version() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.platform_version)
  return platform_version_.Get();
}
inline void ModelConfigProto::set_platform_version(const std::string& value) {
  
  platform_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:adlik.serving.ModelConfigProto.platform_version)
}
inline void ModelConfigProto::set_platform_version(std::string&& value) {
  
  platform_version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:adlik.serving.ModelConfigProto.platform_version)
}
inline void ModelConfigProto::set_platform_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  platform_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:adlik.serving.ModelConfigProto.platform_version)
}
inline void ModelConfigProto::set_platform_version(const char* value,
    size_t size) {
  
  platform_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:adlik.serving.ModelConfigProto.platform_version)
}
inline std::string* ModelConfigProto::mutable_platform_version() {
  
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelConfigProto.platform_version)
  return platform_version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* ModelConfigProto::release_platform_version() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelConfigProto.platform_version)
  
  return platform_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ModelConfigProto::set_allocated_platform_version(std::string* platform_version) {
  if (platform_version != nullptr) {
    
  } else {
    
  }
  platform_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform_version,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelConfigProto.platform_version)
}
inline std::string* ModelConfigProto::unsafe_arena_release_platform_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelConfigProto.platform_version)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return platform_version_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ModelConfigProto::unsafe_arena_set_allocated_platform_version(
    std::string* platform_version) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (platform_version != nullptr) {
    
  } else {
    
  }
  platform_version_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      platform_version, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:adlik.serving.ModelConfigProto.platform_version)
}

// .adlik.serving.VersionPolicyProto version_policy = 4;
inline bool ModelConfigProto::has_version_policy() const {
  return this != internal_default_instance() && version_policy_ != nullptr;
}
inline const ::adlik::serving::VersionPolicyProto& ModelConfigProto::version_policy() const {
  const ::adlik::serving::VersionPolicyProto* p = version_policy_;
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.version_policy)
  return p != nullptr ? *p : *reinterpret_cast<const ::adlik::serving::VersionPolicyProto*>(
      &::adlik::serving::_VersionPolicyProto_default_instance_);
}
inline ::adlik::serving::VersionPolicyProto* ModelConfigProto::release_version_policy() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelConfigProto.version_policy)
  
  ::adlik::serving::VersionPolicyProto* temp = version_policy_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  version_policy_ = nullptr;
  return temp;
}
inline ::adlik::serving::VersionPolicyProto* ModelConfigProto::unsafe_arena_release_version_policy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelConfigProto.version_policy)
  
  ::adlik::serving::VersionPolicyProto* temp = version_policy_;
  version_policy_ = nullptr;
  return temp;
}
inline ::adlik::serving::VersionPolicyProto* ModelConfigProto::mutable_version_policy() {
  
  if (version_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::adlik::serving::VersionPolicyProto>(GetArenaNoVirtual());
    version_policy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelConfigProto.version_policy)
  return version_policy_;
}
inline void ModelConfigProto::set_allocated_version_policy(::adlik::serving::VersionPolicyProto* version_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_policy_);
  }
  if (version_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_policy)->GetArena();
    if (message_arena != submessage_arena) {
      version_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version_policy, submessage_arena);
    }
    
  } else {
    
  }
  version_policy_ = version_policy;
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelConfigProto.version_policy)
}

// int32 max_batch_size = 5;
inline void ModelConfigProto::clear_max_batch_size() {
  max_batch_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelConfigProto::max_batch_size() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.max_batch_size)
  return max_batch_size_;
}
inline void ModelConfigProto::set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_batch_size_ = value;
  // @@protoc_insertion_point(field_set:adlik.serving.ModelConfigProto.max_batch_size)
}

// repeated .adlik.serving.ModelInput input = 6;
inline int ModelConfigProto::input_size() const {
  return input_.size();
}
inline void ModelConfigProto::clear_input() {
  input_.Clear();
}
inline ::adlik::serving::ModelInput* ModelConfigProto::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelConfigProto.input)
  return input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInput >*
ModelConfigProto::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:adlik.serving.ModelConfigProto.input)
  return &input_;
}
inline const ::adlik::serving::ModelInput& ModelConfigProto::input(int index) const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.input)
  return input_.Get(index);
}
inline ::adlik::serving::ModelInput* ModelConfigProto::add_input() {
  // @@protoc_insertion_point(field_add:adlik.serving.ModelConfigProto.input)
  return input_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInput >&
ModelConfigProto::input() const {
  // @@protoc_insertion_point(field_list:adlik.serving.ModelConfigProto.input)
  return input_;
}

// repeated .adlik.serving.ModelOutput output = 7;
inline int ModelConfigProto::output_size() const {
  return output_.size();
}
inline void ModelConfigProto::clear_output() {
  output_.Clear();
}
inline ::adlik::serving::ModelOutput* ModelConfigProto::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelConfigProto.output)
  return output_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelOutput >*
ModelConfigProto::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:adlik.serving.ModelConfigProto.output)
  return &output_;
}
inline const ::adlik::serving::ModelOutput& ModelConfigProto::output(int index) const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.output)
  return output_.Get(index);
}
inline ::adlik::serving::ModelOutput* ModelConfigProto::add_output() {
  // @@protoc_insertion_point(field_add:adlik.serving.ModelConfigProto.output)
  return output_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelOutput >&
ModelConfigProto::output() const {
  // @@protoc_insertion_point(field_list:adlik.serving.ModelConfigProto.output)
  return output_;
}

// .adlik.serving.ModelDynamicBatching dynamic_batching = 12;
inline bool ModelConfigProto::has_dynamic_batching() const {
  return this != internal_default_instance() && dynamic_batching_ != nullptr;
}
inline void ModelConfigProto::clear_dynamic_batching() {
  if (GetArenaNoVirtual() == nullptr && dynamic_batching_ != nullptr) {
    delete dynamic_batching_;
  }
  dynamic_batching_ = nullptr;
}
inline const ::adlik::serving::ModelDynamicBatching& ModelConfigProto::dynamic_batching() const {
  const ::adlik::serving::ModelDynamicBatching* p = dynamic_batching_;
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.dynamic_batching)
  return p != nullptr ? *p : *reinterpret_cast<const ::adlik::serving::ModelDynamicBatching*>(
      &::adlik::serving::_ModelDynamicBatching_default_instance_);
}
inline ::adlik::serving::ModelDynamicBatching* ModelConfigProto::release_dynamic_batching() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelConfigProto.dynamic_batching)
  
  ::adlik::serving::ModelDynamicBatching* temp = dynamic_batching_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  dynamic_batching_ = nullptr;
  return temp;
}
inline ::adlik::serving::ModelDynamicBatching* ModelConfigProto::unsafe_arena_release_dynamic_batching() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelConfigProto.dynamic_batching)
  
  ::adlik::serving::ModelDynamicBatching* temp = dynamic_batching_;
  dynamic_batching_ = nullptr;
  return temp;
}
inline ::adlik::serving::ModelDynamicBatching* ModelConfigProto::mutable_dynamic_batching() {
  
  if (dynamic_batching_ == nullptr) {
    auto* p = CreateMaybeMessage<::adlik::serving::ModelDynamicBatching>(GetArenaNoVirtual());
    dynamic_batching_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelConfigProto.dynamic_batching)
  return dynamic_batching_;
}
inline void ModelConfigProto::set_allocated_dynamic_batching(::adlik::serving::ModelDynamicBatching* dynamic_batching) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dynamic_batching_;
  }
  if (dynamic_batching) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dynamic_batching);
    if (message_arena != submessage_arena) {
      dynamic_batching = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic_batching, submessage_arena);
    }
    
  } else {
    
  }
  dynamic_batching_ = dynamic_batching;
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelConfigProto.dynamic_batching)
}

// repeated .adlik.serving.ModelInstanceGroup instance_group = 8;
inline int ModelConfigProto::instance_group_size() const {
  return instance_group_.size();
}
inline void ModelConfigProto::clear_instance_group() {
  instance_group_.Clear();
}
inline ::adlik::serving::ModelInstanceGroup* ModelConfigProto::mutable_instance_group(int index) {
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelConfigProto.instance_group)
  return instance_group_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInstanceGroup >*
ModelConfigProto::mutable_instance_group() {
  // @@protoc_insertion_point(field_mutable_list:adlik.serving.ModelConfigProto.instance_group)
  return &instance_group_;
}
inline const ::adlik::serving::ModelInstanceGroup& ModelConfigProto::instance_group(int index) const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.instance_group)
  return instance_group_.Get(index);
}
inline ::adlik::serving::ModelInstanceGroup* ModelConfigProto::add_instance_group() {
  // @@protoc_insertion_point(field_add:adlik.serving.ModelConfigProto.instance_group)
  return instance_group_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adlik::serving::ModelInstanceGroup >&
ModelConfigProto::instance_group() const {
  // @@protoc_insertion_point(field_list:adlik.serving.ModelConfigProto.instance_group)
  return instance_group_;
}

// string algorithm = 20;
inline void ModelConfigProto::clear_algorithm() {
  algorithm_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& ModelConfigProto::algorithm() const {
  // @@protoc_insertion_point(field_get:adlik.serving.ModelConfigProto.algorithm)
  return algorithm_.Get();
}
inline void ModelConfigProto::set_algorithm(const std::string& value) {
  
  algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:adlik.serving.ModelConfigProto.algorithm)
}
inline void ModelConfigProto::set_algorithm(std::string&& value) {
  
  algorithm_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:adlik.serving.ModelConfigProto.algorithm)
}
inline void ModelConfigProto::set_algorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:adlik.serving.ModelConfigProto.algorithm)
}
inline void ModelConfigProto::set_algorithm(const char* value,
    size_t size) {
  
  algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:adlik.serving.ModelConfigProto.algorithm)
}
inline std::string* ModelConfigProto::mutable_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:adlik.serving.ModelConfigProto.algorithm)
  return algorithm_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* ModelConfigProto::release_algorithm() {
  // @@protoc_insertion_point(field_release:adlik.serving.ModelConfigProto.algorithm)
  
  return algorithm_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ModelConfigProto::set_allocated_algorithm(std::string* algorithm) {
  if (algorithm != nullptr) {
    
  } else {
    
  }
  algorithm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), algorithm,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:adlik.serving.ModelConfigProto.algorithm)
}
inline std::string* ModelConfigProto::unsafe_arena_release_algorithm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:adlik.serving.ModelConfigProto.algorithm)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return algorithm_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ModelConfigProto::unsafe_arena_set_allocated_algorithm(
    std::string* algorithm) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (algorithm != nullptr) {
    
  } else {
    
  }
  algorithm_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      algorithm, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:adlik.serving.ModelConfigProto.algorithm)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace serving
}  // namespace adlik

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::adlik::serving::ModelInstanceGroup_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::adlik::serving::ModelInstanceGroup_Kind>() {
  return ::adlik::serving::ModelInstanceGroup_Kind_descriptor();
}
template <> struct is_proto_enum< ::adlik::serving::ModelInput_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::adlik::serving::ModelInput_Format>() {
  return ::adlik::serving::ModelInput_Format_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_adlik_5fserving_2fframework_2fdomain_2fmodel_5fconfig_2eproto
